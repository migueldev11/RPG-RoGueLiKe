<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>RPGLIKE XD</title>
<style>
  body {
    font-family: monospace;
    background: #111;
    color: #eee;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    touch-action: manipulation;
  }
  #game-container {
    white-space: pre;
    font-size: 14px;
    line-height: 14px;
    background: #222;
    padding: 10px;
    width: max-content;
    border: 3px solid #555;
    margin-bottom: 10px;
  }
  #hotbar {
    display: flex;
    justify-content: space-around;
    width: 320px;
    background: #333;
    padding: 6px 0;
    font-size: 14px;
    border-top: 2px solid #555;
    flex-wrap: wrap;
  }
  #hotbar div {
    margin: 4px;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  #controls button {
    background: #555;
    border: none;
    color: #eee;
    font-size: 22px;
    width: 50px;
    height: 50px;
    border-radius: 10px;
    user-select: none;
  }
  #controls button:active {
    background: #888;
  }
  #msg {
    width: 320px;
    min-height: 40px;
    background: #111;
    color: #afa;
    font-size: 14px;
    padding: 5px;
    border: 2px solid #555;
    margin-bottom: 10px;
    overflow-wrap: break-word;
  }
  .player { color: #0f0; }
  .enemy { color: #f00; }
  .item { color: #ff0; }
  .stairs { color: #00f; }
  .city-symbol { color: #ccc; }
</style>
</head>
<body>

<h1>RPGLiKe</h1>

<div id="game-container"></div>

<div id="hotbar">
  <div>Vida: <span id="hp">100</span></div>
  <div>Nível: <span id="level">1</span></div>
  <div>XP: <span id="xp">0</span>/<span id="xp-to-next-level">10</span></div>
  <div>Ouro: <span id="gold">0</span></div>
  <div>Andar: <span id="floor">1</span></div>
  <div>Dano: <span id="damage">10</span></div>
  <div>Defesa: <span id="defense">0</span></div>
</div>

<div id="msg"></div>

<div id="controls">
  <button id="up">▲</button>
</div>
<div id="controls">
  <button id="left">◄</button>
  <button id="down">▼</button>
  <button id="right">►</button>
</div>

<script>
(() => {
  const gameContainer = document.getElementById('game-container');
  const hpElem = document.getElementById('hp');
  const levelElem = document.getElementById('level');
  const xpElem = document.getElementById('xp');
  const xpToNextLevelElem = document.getElementById('xp-to-next-level');
  const goldElem = document.getElementById('gold');
  const floorElem = document.getElementById('floor');
  const damageElem = document.getElementById('damage');
  const defenseElem = document.getElementById('defense');
  const msgElem = document.getElementById('msg');

  const MAP_WIDTH = 40;
  const MAP_HEIGHT = 20;

  let map = [];
  let enemies = [];
  let player = {
    x: 0,
    y: 0,
    hp: 100,
    maxHp: 100,
    level: 1,
    xp: 0,
    xpToNextLevel: 10,
    gold: 0,
    floor: 0, // 0 para cidade, >0 para masmorra
    baseDamage: 10,
    defense: 0
  };
  let isGameOver = false;

  const SCENE = {
    CITY: 'city',
    DUNGEON: 'dungeon'
  };
  let currentScene = SCENE.CITY;

  // Definição de inimigos com suas estatísticas e XP
  const enemyTypes = {
    'Z': { hp: 20, damage: 5, xp: 5, gold: 5 },
    'S': { hp: 30, damage: 8, xp: 8, gold: 8 },
    'G': { hp: 15, damage: 10, xp: 12, gold: 12 },
    'A': { hp: 10, damage: 6, xp: 6, gold: 6 },
    'B': { hp: 100, damage: 25, xp: 50, gold: 50 },
    'D': { hp: 80, damage: 15, xp: 30, gold: 30 }
  };
  
  // Definição de itens para compra
  const shopItems = {
      'P': { name: 'Poção de Vida', cost: 10, effect: { type: 'hp', value: 25 } },
      'W': { name: 'Espada', cost: 20, effect: { type: 'damage', value: 5 } },
      'A': { name: 'Armadura', cost: 15, effect: { type: 'defense', value: 3 } }
  };

  // Funções de salvamento e carregamento
  function saveGame() {
    localStorage.setItem('rpglike_save', JSON.stringify({
      player,
      enemies,
      map,
      currentScene
    }));
  }

  function loadGame() {
    const savedData = localStorage.getItem('rpglike_save');
    if (savedData) {
      const data = JSON.parse(savedData);
      player = data.player;
      enemies = data.enemies;
      map = data.map;
      currentScene = data.currentScene;
      addMessage('Jogo carregado com sucesso!');
      return true;
    }
    return false;
  }

  // Função para subir de nível
  function checkLevelUp() {
    while (player.xp >= player.xpToNextLevel) {
      player.level++;
      player.xp -= player.xpToNextLevel;
      player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
      player.maxHp += 20;
      player.hp = player.maxHp;
      player.baseDamage += 2;
      addMessage(`Parabéns! Você subiu para o nível ${player.level}!`);
    }
  }

  // Função que cria um mapa procedural com salas e corredores
  function generateDungeon() {
    map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      let row = [];
      for (let x = 0; x < MAP_WIDTH; x++) {
        row.push('#');
      }
      map.push(row);
    }

    const rooms = [];
    const roomCount = 4 + Math.floor(Math.random() * 3);

    for (let i = 0; i < roomCount; i++) {
      const w = 5 + Math.floor(Math.random() * 6);
      const h = 4 + Math.floor(Math.random() * 4);
      const x = Math.floor(Math.random() * (MAP_WIDTH - w - 1));
      const y = Math.floor(Math.random() * (MAP_HEIGHT - h - 1));
      for (let ry = y; ry < y + h; ry++) {
        for (let rx = x; rx < x + w; rx++) {
          map[ry][rx] = ' ';
        }
      }
      rooms.push({x, y, w, h});
    }

    for (let i = 1; i < rooms.length; i++) {
      const prev = rooms[i - 1];
      const curr = rooms[i];
      const prevX = Math.floor(prev.x + prev.w/2);
      const prevY = Math.floor(prev.y + prev.h/2);
      const currX = Math.floor(curr.x + curr.w/2);
      const currY = Math.floor(curr.y + curr.h/2);

      for (let cx = Math.min(prevX, currX); cx <= Math.max(prevX, currX); cx++) map[prevY][cx] = ' ';
      for (let cy = Math.min(prevY, currY); cy <= Math.max(prevY, currY); cy++) map[cy][currX] = ' ';
    }

    const startRoom = rooms[0];
    player.x = Math.floor(startRoom.x + startRoom.w / 2);
    player.y = Math.floor(startRoom.y + startRoom.h / 2);

    enemies = [];
    const entityCount = 5 + player.floor + Math.floor(Math.random() * 5);
    
    // Adiciona a escada de saída para a cidade
    let placedStairs = false;
    while (!placedStairs) {
      const rx = Math.floor(Math.random() * MAP_WIDTH);
      const ry = Math.floor(Math.random() * MAP_HEIGHT);
      if (map[ry][rx] === ' ' && (rx !== player.x || ry !== player.y)) {
        map[ry][rx] = '<';
        placedStairs = true;
      }
    }
    
    // Adiciona a escada para o próximo andar
    let placedNextStairs = false;
    while (!placedNextStairs) {
      const rx = Math.floor(Math.random() * MAP_WIDTH);
      const ry = Math.floor(Math.random() * MAP_HEIGHT);
      if (map[ry][rx] === ' ' && (rx !== player.x || ry !== player.y)) {
        map[ry][rx] = '>';
        placedNextStairs = true;
      }
    }

    if (player.floor > 0 && player.floor % 5 === 0) { // Boss a cada 5 andares
      let placedBoss = false;
      while (!placedBoss) {
        const rx = Math.floor(Math.random() * MAP_WIDTH);
        const ry = Math.floor(Math.random() * MAP_HEIGHT);
        if (map[ry][rx] === ' ' && (rx !== player.x || ry !== player.y)) {
          enemies.push({ x: rx, y: ry, ...enemyTypes['B'] });
          map[ry][rx] = ' '; // O inimigo é desenhado por cima
          placedBoss = true;
        }
      }
      addMessage(`Você chegou a um andar de chefe! Derrote o Chefe ('B') para prosseguir!`);
    }

    // Adiciona inimigos
    for (let i = 0; i < entityCount; i++) {
      let placed = false;
      while (!placed) {
        const rx = Math.floor(Math.random() * MAP_WIDTH);
        const ry = Math.floor(Math.random() * MAP_HEIGHT);
        const isPlayerPos = (rx === player.x && ry === player.y);
        if (map[ry][rx] === ' ' && !isPlayerPos) {
          const rand = Math.random();
          const enemySymbol = rand < 0.3 ? 'Z' : (rand < 0.5 ? 'S' : (rand < 0.7 ? 'G' : 'A'));
          const enemyStats = enemyTypes[enemySymbol];
          enemies.push({ 
              x: rx, 
              y: ry, 
              hp: enemyStats.hp * player.floor, 
              damage: enemyStats.damage * player.floor, 
              xp: enemyStats.xp,
              gold: enemyStats.gold,
              symbol: enemySymbol 
          });
          placed = true;
        }
      }
    }
  }

  function generateCity() {
    currentScene = SCENE.CITY;
    map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      map.push(Array(MAP_WIDTH).fill(' '));
    }
    // Desenha as construções da cidade
    for (let x = 5; x < 15; x++) for (let y = 5; y < 10; y++) map[y][x] = '#';
    for (let x = 20; x < 30; x++) for (let y = 5; y < 10; y++) map[y][x] = '#';
    for (let x = 5; x < 15; x++) for (let y = 12; y < 17; y++) map[y][x] = '#';
    
    // NPC e lojas
    map[7][8] = 'N'; // NPC
    map[14][8] = 'W'; // Loja de Armas
    map[7][24] = 'P'; // Loja de Poções
    map[14][24] = 'A'; // Loja de Armaduras
    
    // Escada para a masmorra
    map[17][20] = '>';
    
    player.x = 20;
    player.y = 17;
    enemies = [];
    addMessage('Você está na cidade. Fale com o NPC (N) ou entre nas lojas.');
  }

  function draw() {
    let output = '';
    for (let y = 0; y < MAP_HEIGHT; y++) {
      let row = '';
      for (let x = 0; x < MAP_WIDTH; x++) {
        const entity = enemies.find(e => e.x === x && e.y === y);
        if (x === player.x && y === player.y) {
          row += `<span class="player">@</span>`;
        } else if (entity) {
          row += `<span class="enemy">${entity.symbol}</span>`;
        } else if (map[y][x] === '<' || map[y][x] === '>') {
          row += `<span class="stairs">${map[y][x]}</span>`;
        } else if (currentScene === SCENE.CITY && (map[y][x] === 'N' || map[y][x] === 'W' || map[y][x] === 'P' || map[y][x] === 'A')) {
          row += `<span class="city-symbol">${map[y][x]}</span>`;
        } else {
          row += map[y][x];
        }
      }
      output += row + '\n';
    }
    gameContainer.innerHTML = output;
  }

  function updateHotbar() {
    hpElem.textContent = player.hp;
    levelElem.textContent = player.level;
    xpElem.textContent = player.xp;
    xpToNextLevelElem.textContent = player.xpToNextLevel;
    goldElem.textContent = player.gold;
    floorElem.textContent = player.floor;
    damageElem.textContent = player.baseDamage;
    defenseElem.textContent = player.defense;
  }

  function canMoveTo(x, y) {
    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
    if (map[y][x] === '#') return false;
    return true;
  }

  function handleCombat(enemy, index) {
    const playerDamage = Math.max(0, player.baseDamage - enemy.defense + Math.floor(Math.random() * 5));
    const enemyDamage = Math.max(0, enemy.damage - player.defense + Math.floor(Math.random() * 3));
    
    enemy.hp -= playerDamage;
    addMessage(`Você atacou o ${enemy.symbol}, causando ${playerDamage} de dano! (${enemy.hp} HP restantes)`);
    
    if (enemy.hp <= 0) {
      addMessage(`Você derrotou o ${enemy.symbol}!`);
      player.xp += enemy.xp;
      player.gold += enemy.gold;
      enemies.splice(index, 1);
      checkLevelUp();
      return;
    }

    player.hp -= enemyDamage;
    addMessage(`O ${enemy.symbol} te atacou, causando ${enemyDamage} de dano!`);
    
    if (player.hp <= 0) {
      isGameOver = true;
      addMessage('Você morreu... Fim de jogo!');
      // TODO: Adicionar tela de game over
    }
  }

  function movePlayer(dx, dy) {
    if (isGameOver) return;
    
    const nx = player.x + dx;
    const ny = player.y + dy;
    
    const enemyIndex = enemies.findIndex(e => e.x === nx && e.y === ny);

    if (enemyIndex !== -1) {
      handleCombat(enemies[enemyIndex], enemyIndex);
    } else if (canMoveTo(nx, ny)) {
      player.x = nx;
      player.y = ny;
      
      const tile = map[ny][nx];
      if (currentScene === SCENE.DUNGEON) {
          if (tile === '>') {
            player.floor++;
            addMessage(`Você desceu para o Andar ${player.floor}!`);
            generateDungeon();
          } else if (tile === '<') {
            player.floor = 0;
            addMessage('Você retornou para a cidade.');
            generateCity();
          } else {
            addMessage(`Você se moveu para (${nx},${ny})`);
          }
      } else { // Cidade
          if (tile === 'N') {
              addMessage("Olá aventureiro! O mundo lá fora é perigoso. Se prepare e boa sorte!");
          } else if (tile === 'W') {
              buyItem(shopItems['W']);
          } else if (tile === 'P') {
              buyItem(shopItems['P']);
          } else if (tile === 'A') {
              buyItem(shopItems['A']);
          } else if (tile === '>') {
              player.floor = 1;
              addMessage('Você entrou na masmorra...');
              generateDungeon();
          } else {
              addMessage(`Você se moveu para (${nx},${ny})`);
          }
      }
    } else {
      addMessage('Não pode andar aí!');
    }
    
    saveGame();
    draw();
    updateHotbar();
  }

  function buyItem(item) {
      if (player.gold >= item.cost) {
          player.gold -= item.cost;
          if (item.effect.type === 'hp') {
              player.hp = Math.min(player.maxHp, player.hp + item.effect.value);
              addMessage(`Você comprou uma ${item.name} e recuperou ${item.effect.value} de vida!`);
          } else if (item.effect.type === 'damage') {
              player.baseDamage += item.effect.value;
              addMessage(`Você comprou uma ${item.name} e seu dano aumentou em ${item.effect.value}!`);
          } else if (item.effect.type === 'defense') {
              player.defense += item.effect.value;
              addMessage(`Você comprou uma ${item.name} e sua defesa aumentou em ${item.effect.value}!`);
          }
      } else {
          addMessage(`Você não tem ouro suficiente para comprar ${item.name}! Precisa de ${item.cost} de ouro.`);
      }
  }

  function moveEnemies() {
    enemies.forEach(enemy => {
      const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
      const randomDirection = directions[Math.floor(Math.random() * directions.length)];
      
      const nx = enemy.x + randomDirection[0];
      const ny = enemy.y + randomDirection[1];
      
      if (canMoveTo(nx, ny) && (nx !== player.x || ny !== player.y)) {
        enemy.x = nx;
        enemy.y = ny;
      }
    });
  }

  function addMessage(text) {
    msgElem.textContent = text;
  }

  // Controles botões
  document.getElementById('up').onclick = () => movePlayer(0, -1);
  document.getElementById('down').onclick = () => movePlayer(0, 1);
  document.getElementById('left').onclick = () => movePlayer(-1, 0);
  document.getElementById('right').onclick = () => movePlayer(1, 0);

  // Teclado para desktop
  window.addEventListener('keydown', e => {
    if (isGameOver) return;
    switch (e.key) {
      case 'ArrowUp': movePlayer(0, -1); break;
      case 'ArrowDown': movePlayer(0, 1); break;
      case 'ArrowLeft': movePlayer(-1, 0); break;
      case 'ArrowRight': movePlayer(1, 0); break;
    }
  });

  // Loop principal do jogo
  function gameLoop() {
    if (isGameOver) return;
    if (currentScene === SCENE.DUNGEON) {
      moveEnemies();
    }
    draw();
    updateHotbar();
    setTimeout(gameLoop, 500); // Roda a cada 500ms para um movimento mais fluido
  }

  // Inicia o jogo
  function startGame() {
    if (!loadGame()) {
      isGameOver = false;
      player = {
        x: 0,
        y: 0,
        hp: 100,
        maxHp: 100,
        level: 1,
        xp: 0,
        xpToNextLevel: 10,
        gold: 0,
        floor: 0,
        baseDamage: 10,
        defense: 0
      };
      generateCity();
      addMessage('Bem-vindo ao RPGLiKe! Explore a cidade e depois desça para a masmorra.');
    }
    draw();
    updateHotbar();
    gameLoop();
  }
  
  startGame();

})();
</script>

</body>
</html>
