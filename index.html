<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Rogue-like Turnos ASCII</title>
<style>
  body {
    font-family: monospace;
    background: #111;
    color: #eee;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    touch-action: manipulation;
  }
  h1 {
    margin: 10px 0;
    font-size: 18px;
    text-align: center;
  }
  #game-container {
    border: 3px solid #555;
    background: #222;
    margin-bottom: 10px;
    width: 320px;
    height: 240px;
  }
  canvas {
    width: 320px;
    height: 240px;
    image-rendering: pixelated;
    touch-action: none;
    background: #222;
  }
  #hotbar {
    display: flex;
    justify-content: space-around;
    width: 320px;
    background: #333;
    padding: 6px 0;
    font-size: 14px;
    border-top: 2px solid #555;
    margin-bottom: 10px;
  }
  #controls {
    width: 320px;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }
  #controls > div {
    display: flex;
    justify-content: center;
    margin-top: 5px;
    gap: 10px;
  }
  #controls button {
    background: #555;
    border: none;
    color: #eee;
    font-size: 24px;
    width: 60px;
    height: 60px;
    border-radius: 10px;
    touch-action: manipulation;
    user-select: none;
  }
  #controls button:active {
    background: #888;
  }
  #class-selection {
    margin-top: 20px;
    text-align: center;
  }
  #class-selection button {
    font-size: 18px;
    padding: 8px 16px;
    margin: 0 5px;
    cursor: pointer;
    user-select: none;
  }
  #msg {
    width: 320px;
    height: 60px;
    background: #111;
    color: #afa;
    font-size: 14px;
    padding: 5px;
    border: 2px solid #555;
    margin-bottom: 10px;
    overflow-y: auto;
  }
</style>
</head>
<body>
  <h1>Rogue-like Turnos ASCII</h1>
  <div id="game-container">
    <canvas id="game" width="320" height="240"></canvas>
  </div>

  <div id="hotbar">
    <div>Vida: <span id="hp">100</span></div>
    <div>MP: <span id="mp">50</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Itens: <span id="items">Nenhum</span></div>
    <div>Tempo: <span id="time">0s</span></div>
  </div>

  <div id="msg"></div>

  <div id="controls">
    <button id="magic-btn">Magia (10 MP)</button>
    <button id="open-chest-btn" disabled>Abrir Baú</button>
  </div>

  <div id="controls">
    <button id="up">▲</button>
    <div>
      <button id="left">◄</button>
      <button id="down">▼</button>
      <button id="right">►</button>
    </div>
  </div>

  <div id="class-selection">
    <h2>Escolha sua Classe</h2>
    <button data-class="warrior">Guerreiro</button>
    <button data-class="mage">Mago</button>
    <button data-class="rogue">Ladino</button>
    <br/><br/>
    <button id="load-save">Carregar Save</button>
    <button id="delete-save">Apagar Save</button>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const TILE_W = 8;
  const TILE_H = 12;

  const MAP_WIDTH = 40;
  const MAP_HEIGHT = 20;

  let map = [];
  let player = null;
  let enemies = [];
  let chests = [];
  let gameStarted = false;
  let gameTime = 0;
  let currentTurn = 'player';
  let msgElem = document.getElementById('msg');
  let openChestBtn = document.getElementById('open-chest-btn');
  let magicBtn = document.getElementById('magic-btn');
  let currentLevel = 1;

  const itemList = [
    { name: 'Poção de Vida', type: 'heal', value: 30 },
    { name: 'Poção de MP', type: 'mp', value: 20 },
    { name: 'Espada +1', type: 'attack', value: 3 },
    { name: 'Escudo +1', type: 'defense', value: 2 }
  ];

  const classes = {
    warrior: { hp: 120, mp: 20, attack: 10, defense: 5, magicAttack: 4 },
    mage: { hp: 80, mp: 50, attack: 6, defense: 3, magicAttack: 15 },
    rogue: { hp: 90, mp: 30, attack: 12, defense: 4, magicAttack: 8 }
  };

  const enemyTypes = [
    { name: 'Goblin', hp: 20, attack: 5, defense: 2, magicAttack: 0, char: 'g' },
    { name: 'Esqueleto', hp: 30, attack: 7, defense: 3, magicAttack: 0, char: 's' },
    { name: 'Mago das Sombras', hp: 25, attack: 4, defense: 2, magicAttack: 8, char: 'm' }
  ];

  function addMessage(text) {
    msgElem.innerText = text;
  }

  function saveGame() {
    if (!gameStarted) return;
    const saveData = { player, enemies, chests, map, gameTime, currentLevel, currentTurn };
    localStorage.setItem('roguelikeSave', JSON.stringify(saveData));
    addMessage('Jogo salvo!');
  }

  function loadGame() {
    const saveDataStr = localStorage.getItem('roguelikeSave');
    if (!saveDataStr) {
      addMessage('Nenhum save encontrado.');
      return false;
    }
    try {
      const saveData = JSON.parse(saveDataStr);
      player = saveData.player;
      enemies = saveData.enemies;
      chests = saveData.chests;
      map = saveData.map;
      gameTime = saveData.gameTime;
      currentLevel = saveData.currentLevel;
      currentTurn = saveData.currentTurn;
      gameStarted = true;
      updateHotbar();
      draw();
      document.getElementById('class-selection').style.display = 'none';
      addMessage('Save carregado com sucesso!');
      return true;
    } catch(e) {
      addMessage('Erro ao carregar save.');
      return false;
    }
  }

  function deleteSave() {
    localStorage.removeItem('roguelikeSave');
    addMessage('Save apagado!');
  }

  function generateMap() {
    map = Array.from({ length: MAP_HEIGHT }, () =>
      Array.from({ length: MAP_WIDTH }, () => '#')
    );
    const rooms = [];
    function carveRoom(x, y, w, h) {
      for (let i = y; i < y + h; i++) {
        for (let j = x; j < x + w; j++) {
          if (i >= 0 && i < MAP_HEIGHT && j >= 0 && j < MAP_WIDTH) map[i][j] = '.';
        }
      }
      rooms.push({x, y, w, h});
    }
    const roomCount = 4 + Math.floor(Math.random() * 3);
    for (let i = 0; i < roomCount; i++) {
      let w = 6 + Math.floor(Math.random() * 5);
      let h = 4 + Math.floor(Math.random() * 4);
      let x = Math.floor(Math.random() * (MAP_WIDTH - w - 1));
      let y = Math.floor(Math.random() * (MAP_HEIGHT - h - 1));
      carveRoom(x, y, w, h);
    }
    function connectRooms(r1, r2) {
      let x1 = Math.floor(r1.x + r1.w/2);
      let y1 = Math.floor(r1.y + r1.h/2);
      let x2 = Math.floor(r2.x + r2.w/2);
      let y2 = Math.floor(r2.y + r2.h/2);
      while (x1 !== x2) {
        map[y1][x1] = '.';
        x1 += x1 < x2 ? 1 : -1;
      }
      while (y1 !== y2) {
        map[y1][x1] = '.';
        y1 += y1 < y2 ? 1 : -1;
      }
    }
    for (let i = 0; i < rooms.length - 1; i++) {
      connectRooms(rooms[i], rooms[i + 1]);
    }
    chests = [];
    for (let i = 0; i < rooms.length; i++) {
      if (Math.random() < 0.6) {
        let r = rooms[i];
        let cx = r.x + 1 + Math.floor(Math.random() * (r.w - 2));
        let cy = r.y + 1 + Math.floor(Math.random() * (r.h - 2));
        if (map[cy][cx] === '.') {
          map[cy][cx] = 'C';
          chests.push({x: cx, y: cy, opened: false, items: generateChestItems()});
        }
      }
    }
  }

  function generateChestItems() {
    const count = 1 + Math.floor(Math.random() * 2);
    let chestItems = [];
    for (let i = 0; i < count; i++) {
      const idx = Math.floor(Math.random() * itemList.length);
      chestItems.push(itemList[idx].name);
    }
    return chestItems;
  }

  function drawMap() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = `${TILE_H}px monospace`;
    ctx.textBaseline = 'top';
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        let ch = map[y][x];
        let color = '#999';
        if (ch === '#') color = '#555';
        else if (ch === '.') color = '#ccc';
        else if (ch === 'C') {
          const chest = chests.find(c => c.x === x && c.y === y);
          color = chest && chest.opened ? '#777' : '#b8860b';
        }
        ctx.fillStyle = color;
        ctx.fillText(ch, x * TILE_W, y * TILE_H);
      }
    }
  }

  function drawEntities() {
    ctx.fillStyle = 'lime';
    ctx.fillText('@', player.x * TILE_W, player.y * TILE_H);
    enemies.forEach(e => {
      ctx.fillStyle = 'red';
      ctx.fillText(e.char || 'e', e.x * TILE_W, e.y * TILE_H);
    });
  }

  function draw() {
    drawMap();
    drawEntities();
  }

  function updateHotbar() {
    document.getElementById('hp').innerText = player.hp;
    document.getElementById('mp').innerText = player.mp;
    document.getElementById('level').innerText = player.level;
    document.getElementById('items').innerText = player.items.length > 0 ? player.items.join(', ') : 'Nenhum';
    document.getElementById('time').innerText = Math.floor(gameTime) + 's';
    let chestHere = chests.find(c => c.x === player.x && c.y === player.y && !c.opened);
    openChestBtn.disabled = !chestHere || currentTurn !== 'player';
    magicBtn.disabled = player.mp < 10 || currentTurn !== 'player';
  }

  function createPlayer(chosenClass) {
    const base = classes[chosenClass];
    player = {
      x: 2,
      y: 2,
      hp: base.hp,
      maxHp: base.hp,
      mp: base.mp,
      maxMp: base.mp,
      attack: base.attack,
      defense: base.defense,
      magicAttack: base.magicAttack,
      level: 1,
      exp: 0,
      items: [],
      class: chosenClass
    };
  }

  function spawnEnemies() {
    enemies = [];
    let enemyCount = 5 + currentLevel;
    for (let i = 0; i < enemyCount; i++) {
      let x, y;
      do {
        x = Math.floor(Math.random() * MAP_WIDTH);
        y = Math.floor(Math.random() * MAP_HEIGHT);
      } while (
        map[y][x] === '#' || map[y][x] === 'C' || (x === player.x && y === player.y) || enemies.some(en => en.x === x && en.y === y)
      );
      let et = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
      enemies.push({
        x, y,
        hp: et.hp + currentLevel * 5,
        attack: et.attack + currentLevel,
        defense: et.defense + Math.floor(currentLevel/2),
        magicAttack: et.magicAttack + Math.floor(currentLevel/2),
        name: et.name,
        char: et.char
      });
    }
  }

  function isWalkable(x, y) {
    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
    if (map[y][x] === '#') return false;
    if (enemies.some(e => e.x === x && e.y === y)) return false;
    return true;
  }

  function movePlayer(dx, dy) {
    if (currentTurn !== 'player') return;
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) return;

    const enemy = enemies.find(e => e.x === nx && e.y === ny);
    if (enemy) {
      attack(player, enemy, false);
      if (enemy.hp <= 0) {
        enemies = enemies.filter(e => e.hp > 0);
        player.exp += 10;
        if (player.exp >= player.level * 20) levelUp();
        addMessage(`Você matou o ${enemy.name}!`);
      } else {
        addMessage(`Você atacou o ${enemy.name}, vida dele: ${enemy.hp}`);
      }
      currentTurn = 'enemy';
    } else if (map[ny][nx] !== '#') {
      player.x = nx;
      player.y = ny;
      currentTurn = 'enemy';
      addMessage(`Você se moveu para (${nx},${ny})`);
    } else {
      addMessage('Não pode andar aí!');
    }
    updateHotbar();
    draw();
  }

  function attack(attacker, defender, isMagic) {
    let attackValue = isMagic ? attacker.magicAttack : attacker.attack;
    let defenseValue = defender.defense;
    if (isMagic) defenseValue = Math.floor(defender.defense / 2);
    const damage = Math.max(1, attackValue - defenseValue);
    defender.hp -= damage;
  }

  function enemyTurn() {
    enemies.forEach(e => {
      if (e.hp <= 0) return;
      let dist = Math.abs(e.x - player.x) + Math.abs(e.y - player.y);
      if (dist === 1) {
        if (e.magicAttack > 0 && Math.random() < 0.3) {
          attack(e, player, true);
          addMessage(`${e.name} usou magia em você! Vida: ${player.hp}`);
        } else {
          attack(e, player, false);
          addMessage(`${e.name} atacou você! Vida: ${player.hp}`);
        }
      } else {
        let dx = 0, dy = 0;
        if (e.x < player.x) dx = 1;
        else if (e.x > player.x) dx = -1;
        if (e.y < player.y) dy = 1;
        else if (e.y > player.y) dy = -1;
        let nx = e.x + dx;
        let ny = e.y + dy;
        if (isWalkable(nx, ny) && !(nx === player.x && ny === player.y)) {
          e.x = nx;
          e.y = ny;
        }
      }
    });
    if (player.hp <= 0) {
      addMessage('Você morreu! Recarregue a página para tentar novamente.');
      currentTurn = 'dead';
      return;
    }
    currentTurn = 'player';
    updateHotbar();
    draw();
  }

  function levelUp() {
    player.level++;
    player.exp = 0;
    player.maxHp += 20;
    player.hp = player.maxHp;
    player.maxMp += 10;
    player.mp = player.maxMp;
    player.attack += 3;
    player.defense += 2;
    player.magicAttack += 3;
    addMessage(`Você subiu para o nível ${player.level}!`);
    // Novo nível = novo mapa + inimigos
    currentLevel++;
    generateMap();
    spawnEnemies();
    player.x = 2;
    player.y = 2;
  }
function useMagic() {
  if (currentTurn !== 'player') return;
  if (player.mp < 10) {
    addMessage('MP insuficiente para usar magia!');
    return;
  }
  // Magia ataca inimigo adjacente com mais vida
  const adjacentEnemies = enemies.filter(e => {
    const dx = Math.abs(e.x - player.x);
    const dy = Math.abs(e.y - player.y);
    return dx + dy === 1;
  });
  if (adjacentEnemies.length === 0) {
    addMessage('Nenhum inimigo adjacente para atacar com magia!');
    return;
  }
  // Ataca inimigo com mais HP adjacente
  const target = adjacentEnemies.reduce((a, b) => (a.hp > b.hp ? a : b));
  player.mp -= 10;
  attack(player, target, true);
  addMessage(`Você lançou magia no ${target.name}, vida dele: ${target.hp}`);
  if (target.hp <= 0) {
    enemies = enemies.filter(e => e.hp > 0);
    player.exp += 15;
    if (player.exp >= player.level * 20) levelUp();
    addMessage(`Você matou o ${target.name} com magia!`);
  }
  currentTurn = 'enemy';
  updateHotbar();
  draw();
}

openChestBtn.onclick = () => {
  if (currentTurn !== 'player') return;
  const chest = chests.find(c => c.x === player.x && c.y === player.y && !c.opened);
  if (!chest) {
    addMessage('Não há baú aqui para abrir.');
    return;
  }
  chest.opened = true;
  player.items.push(...chest.items);
  addMessage(`Você abriu o baú e achou: ${chest.items.join(', ')}`);
  map[player.y][player.x] = '.';
  updateHotbar();
  draw();
  saveGame();
};

magicBtn.onclick = () => useMagic();

document.getElementById('up').onclick = () => {
  movePlayer(0, -1);
  if (currentTurn === 'enemy') setTimeout(enemyTurn, 300);
};
document.getElementById('down').onclick = () => {
  movePlayer(0, 1);
  if (currentTurn === 'enemy') setTimeout(enemyTurn, 300);
};
document.getElementById('left').onclick = () => {
  movePlayer(-1, 0);
  if (currentTurn === 'enemy') setTimeout(enemyTurn, 300);
};
document.getElementById('right').onclick = () => {
  movePlayer(1, 0);
  if (currentTurn === 'enemy') setTimeout(enemyTurn, 300);
};

document.getElementById('load-save').onclick = () => {
  if (!loadGame()) {
    addMessage('Nenhum save para carregar.');
  } else {
    document.getElementById('class-selection').style.display = 'none';
  }
};
document.getElementById('delete-save').onclick = () => {
  deleteSave();
};

document.querySelectorAll('#class-selection button[data-class]').forEach(btn => {
  btn.onclick = () => {
    const cls = btn.getAttribute('data-class');
    createPlayer(cls);
    currentLevel = 1;
    gameTime = 0;
    generateMap();
    spawnEnemies();
    gameStarted = true;
    currentTurn = 'player';
    document.getElementById('class-selection').style.display = 'none';
    updateHotbar();
    draw();
    addMessage(`Classe ${cls} selecionada! Boa sorte!`);
  };
});

// Atualiza o tempo de jogo a cada segundo
setInterval(() => {
  if (gameStarted && currentTurn !== 'dead') {
    gameTime += 1;
    updateHotbar();
  }
}, 1000);

// Controle via teclado (setas + magia com M, abrir baú com O)
window.addEventListener('keydown', e => {
  if (!gameStarted || currentTurn !== 'player') return;
  switch (e.key) {
    case 'ArrowUp': movePlayer(0, -1); break;
    case 'ArrowDown': movePlayer(0, 1); break;
    case 'ArrowLeft': movePlayer(-1, 0); break;
    case 'ArrowRight': movePlayer(1, 0); break;
    case 'm': case 'M': useMagic(); break;
    case 'o': case 'O': openChestBtn.click(); break;
  }
  if (currentTurn === 'enemy') setTimeout(enemyTurn, 300);
});

})();
</script>
</body>
</html>