<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>RPGLIKE XD</title>
<style>
  body {
    font-family: monospace;
    background: #111;
    color: #eee;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    touch-action: manipulation;
  }
  #game-container {
    white-space: pre;
    font-size: 14px;
    line-height: 14px;
    background: #222;
    padding: 10px;
    width: max-content;
    border: 3px solid #555;
    margin-bottom: 10px;
  }
  #hotbar {
    display: flex;
    justify-content: space-around;
    width: 320px;
    background: #333;
    padding: 6px 0;
    font-size: 14px;
    border-top: 2px solid #555;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  #controls button {
    background: #555;
    border: none;
    color: #eee;
    font-size: 22px;
    width: 50px;
    height: 50px;
    border-radius: 10px;
    user-select: none;
  }
  #controls button:active {
    background: #888;
  }
  #msg {
    width: 320px;
    min-height: 40px;
    background: #111;
    color: #afa;
    font-size: 14px;
    padding: 5px;
    border: 2px solid #555;
    margin-bottom: 10px;
    overflow-wrap: break-word;
  }
  .player { color: #0f0; }
  .enemy { color: #f00; }
  .item { color: #ff0; }
  .stairs { color: #00f; }
</style>
</head>
<body>

<h1>RPGLiKe</h1>

<div id="game-container"></div>

<div id="hotbar">
  <div>Vida: <span id="hp">100</span></div>
  <div>Andar: <span id="floor">1</span></div>
  <div>Tempo: <span id="time">0s</span></div>
  <div>Dano: <span id="damage">10</span></div>
</div>

<div id="msg"></div>

<div id="controls">
  <button id="up">▲</button>
</div>
<div id="controls">
  <button id="left">◄</button>
  <button id="down">▼</button>
  <button id="right">►</button>
</div>

<script>
(() => {
  const gameContainer = document.getElementById('game-container');
  const hpElem = document.getElementById('hp');
  const floorElem = document.getElementById('floor');
  const timeElem = document.getElementById('time');
  const damageElem = document.getElementById('damage');
  const msgElem = document.getElementById('msg');

  const MAP_WIDTH = 40;
  const MAP_HEIGHT = 20;
  const TOTAL_FLOORS = 5;

  let map = [];
  let player = {
    x: 0,
    y: 0,
    hp: 100,
    floor: 1,
    baseDamage: 10
  };
  let enemies = [];
  let gameTime = 0;
  let isGameOver = false;

  // Função que cria um mapa procedural com salas e corredores
  function generateDungeon() {
    map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      let row = [];
      for (let x = 0; x < MAP_WIDTH; x++) {
        row.push('#');
      }
      map.push(row);
    }

    const rooms = [];
    const roomCount = 4 + Math.floor(Math.random() * 3);

    for (let i = 0; i < roomCount; i++) {
      const w = 5 + Math.floor(Math.random() * 6);
      const h = 4 + Math.floor(Math.random() * 4);
      const x = Math.floor(Math.random() * (MAP_WIDTH - w - 1));
      const y = Math.floor(Math.random() * (MAP_HEIGHT - h - 1));

      for (let ry = y; ry < y + h; ry++) {
        for (let rx = x; rx < x + w; rx++) {
          map[ry][rx] = ' ';
        }
      }
      rooms.push({x, y, w, h});
    }

    for (let i = 1; i < rooms.length; i++) {
      const prev = rooms[i - 1];
      const curr = rooms[i];
      const prevX = Math.floor(prev.x + prev.w/2);
      const prevY = Math.floor(prev.y + prev.h/2);
      const currX = Math.floor(curr.x + curr.w/2);
      const currY = Math.floor(curr.y + curr.h/2);

      for (let cx = Math.min(prevX, currX); cx <= Math.max(prevX, currX); cx++) {
        map[prevY][cx] = ' ';
      }
      for (let cy = Math.min(prevY, currY); cy <= Math.max(prevY, currY); cy++) {
        map[cy][currX] = ' ';
      }
    }

    const startRoom = rooms[0];
    player.x = Math.floor(startRoom.x + startRoom.w / 2);
    player.y = Math.floor(startRoom.y + startRoom.h / 2);

    enemies = [];
    const entityCount = 5 + player.floor + Math.floor(Math.random() * 5); // Aumenta a quantidade por andar

    if (player.floor === TOTAL_FLOORS) {
      // Adiciona o chefe no último andar
      let placedBoss = false;
      while (!placedBoss) {
        const rx = Math.floor(Math.random() * MAP_WIDTH);
        const ry = Math.floor(Math.random() * MAP_HEIGHT);
        if (map[ry][rx] === ' ' && (rx !== player.x || ry !== player.y)) {
          enemies.push({ x: rx, y: ry, hp: 100, damage: 25, symbol: 'B' });
          placedBoss = true;
        }
      }
      addMessage(`Você chegou ao último andar! Derrote o Chefe ('B') para vencer!`);
    } else {
      // Adiciona a escada para o próximo andar
      let placedStairs = false;
      while (!placedStairs) {
        const rx = Math.floor(Math.random() * MAP_WIDTH);
        const ry = Math.floor(Math.random() * MAP_HEIGHT);
        if (map[ry][rx] === ' ' && (rx !== player.x || ry !== player.y)) {
          map[ry][rx] = '<';
          placedStairs = true;
        }
      }
    }

    // Adiciona inimigos e itens
    for (let i = 0; i < entityCount; i++) {
      let placed = false;
      while (!placed) {
        const rx = Math.floor(Math.random() * MAP_WIDTH);
        const ry = Math.floor(Math.random() * MAP_HEIGHT);
        const isPlayerPos = (rx === player.x && ry === player.y);
        const isOccupied = map[ry][rx] !== ' ';

        if (map[ry][rx] === ' ' && !isPlayerPos) {
          // Tipos de inimigos e itens
          const rand = Math.random();
          if (rand < 0.6) { // Zumbi
            enemies.push({ x: rx, y: ry, hp: 20 * player.floor, damage: 5 * player.floor, symbol: 'Z' });
          } else if (rand < 0.8) { // Esqueleto
            enemies.push({ x: rx, y: ry, hp: 30 * player.floor, damage: 8 * player.floor, symbol: 'S' });
          } else if (rand < 0.9) { // Goblin
            enemies.push({ x: rx, y: ry, hp: 15 * player.floor, damage: 10 * player.floor, symbol: 'G' });
          } else if (rand < 0.95) { // Poção
            map[ry][rx] = 'P';
          } else { // Arma
            map[ry][rx] = 'W';
          }
          placed = true;
        }
      }
    }
  }

  // Desenha o mapa no div em texto ASCII com cores
  function draw() {
    let output = '';
    for (let y = 0; y < MAP_HEIGHT; y++) {
      let row = '';
      for (let x = 0; x < MAP_WIDTH; x++) {
        const entity = enemies.find(e => e.x === x && e.y === y);
        if (x === player.x && y === player.y) {
          row += `<span class="player">@</span>`;
        } else if (entity) {
          row += `<span class="enemy">${entity.symbol}</span>`;
        } else if (map[y][x] === 'P' || map[y][x] === 'W') {
          row += `<span class="item">${map[y][x]}</span>`;
        } else if (map[y][x] === '<') {
          row += `<span class="stairs"><</span>`;
        } else {
          row += map[y][x];
        }
      }
      output += row + '\n';
    }
    gameContainer.innerHTML = output;
  }

  // Atualiza hotbar
  function updateHotbar() {
    hpElem.textContent = player.hp;
    floorElem.textContent = player.floor;
    timeElem.textContent = gameTime + 's';
    damageElem.textContent = player.baseDamage;
  }

  // Checa se pode andar (não andar em parede ou em inimigo)
  function canMoveTo(x, y) {
    if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
    if (map[y][x] === '#') return false;
    return true;
  }

  // Lógica de combate
  function handleCombat(enemy, index) {
    const playerDamage = player.baseDamage + Math.floor(Math.random() * 5); // Dano com aleatoriedade
    const enemyDamage = enemy.damage;
    
    enemy.hp -= playerDamage;
    addMessage(`Você atacou o ${enemy.symbol}, causando ${playerDamage} de dano! (${enemy.hp} HP restantes)`);
    
    if (enemy.hp <= 0) {
      addMessage(`Você derrotou o ${enemy.symbol}!`);
      enemies.splice(index, 1); // Remove o inimigo
      return;
    }

    player.hp -= enemyDamage;
    addMessage(`O ${enemy.symbol} te atacou, causando ${enemyDamage} de dano!`);
    
    if (player.hp <= 0) {
      isGameOver = true;
      addMessage('Você morreu... Fim de jogo!');
      // TODO: Adicionar tela de game over
    }
  }

  // Movimenta o jogador
  function movePlayer(dx, dy) {
    if (isGameOver) return;
    
    const nx = player.x + dx;
    const ny = player.y + dy;
    
    const enemyIndex = enemies.findIndex(e => e.x === nx && e.y === ny);

    if (enemyIndex !== -1) {
      handleCombat(enemies[enemyIndex], enemyIndex);
    } else if (canMoveTo(nx, ny)) {
      player.x = nx;
      player.y = ny;
      
      const tile = map[ny][nx];
      if (tile === 'P') {
        player.hp = Math.min(100, player.hp + 25);
        map[ny][nx] = ' ';
        addMessage('Você encontrou uma poção e recuperou 25 de vida!');
      } else if (tile === 'W') {
        player.baseDamage += 5;
        map[ny][nx] = ' ';
        addMessage('Você encontrou uma nova arma e seu dano aumentou!');
      } else if (tile === '<') {
        player.floor++;
        addMessage(`Você desceu para o Andar ${player.floor}!`);
        generateDungeon();
      } else {
        addMessage(`Você se moveu para (${nx},${ny})`);
      }
    } else {
      addMessage('Não pode andar aí!');
    }
    
    draw();
    updateHotbar();
  }

  // Movimenta os inimigos de forma aleatória
  function moveEnemies() {
    enemies.forEach(enemy => {
      const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
      const randomDirection = directions[Math.floor(Math.random() * directions.length)];
      
      const nx = enemy.x + randomDirection[0];
      const ny = enemy.y + randomDirection[1];
      
      if (canMoveTo(nx, ny) && (nx !== player.x || ny !== player.y)) {
        enemy.x = nx;
        enemy.y = ny;
      }
    });
  }

  // Exibe mensagem
  function addMessage(text) {
    msgElem.textContent = text;
  }

  // Controles botões
  document.getElementById('up').onclick = () => movePlayer(0, -1);
  document.getElementById('down').onclick = () => movePlayer(0, 1);
  document.getElementById('left').onclick = () => movePlayer(-1, 0);
  document.getElementById('right').onclick = () => movePlayer(1, 0);

  // Teclado para desktop
  window.addEventListener('keydown', e => {
    if (isGameOver) return;
    switch (e.key) {
      case 'ArrowUp': movePlayer(0, -1); break;
      case 'ArrowDown': movePlayer(0, 1); break;
      case 'ArrowLeft': movePlayer(-1, 0); break;
      case 'ArrowRight': movePlayer(1, 0); break;
    }
  });

  // Loop principal do jogo
  function gameLoop() {
    if (isGameOver) return;
    gameTime++;
    moveEnemies();
    draw();
    updateHotbar();
    
    // Condição de vitória (derrotar o boss no último andar)
    if (player.floor === TOTAL_FLOORS && enemies.length === 0) {
      isGameOver = true;
      addMessage('Parabéns! Você derrotou o Chefe e venceu o jogo!');
    } else {
      setTimeout(gameLoop, 1000); // Roda a cada segundo
    }
  }

  // Inicia o jogo
  function startGame() {
    isGameOver = false;
    player = { x: 0, y: 0, hp: 100, floor: 1, baseDamage: 10 };
    gameTime = 0;
    generateDungeon();
    draw();
    updateHotbar();
    gameLoop();
    addMessage(`Bem-vindo à masmorra! Derrote o Chefe no Andar ${TOTAL_FLOORS} para vencer.`);
  }
  
  startGame();

})();
</script>

</body>
</html>
